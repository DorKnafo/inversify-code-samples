{
  "name": "inversify",
  "version": "1.0.0",
  "description": "A lightweight IoC container written in TypeScript.",
  "main": "dist/inversify.js",
  "directories": {
    "test": "test"
  },
  "scripts": {
    "test": "gulp"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/inversify/InversifyJS.git"
  },
  "keywords": [
    "IoC",
    "container",
    "JavaScript",
    "TypeScript",
    "dependency",
    "inversion",
    "inversion",
    "control"
  ],
  "author": {
    "name": "Remo H. Jansen"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/inversify/InversifyJS/issues"
  },
  "homepage": "http://inversify.io",
  "engines": {},
  "dependencies": {},
  "devDependencies": {
    "browserify": "^9.0.8",
    "chai": "^2.2.0",
    "gulp": "^3.8.11",
    "gulp-coveralls": "^0.1.3",
    "gulp-docco": "0.0.4",
    "gulp-header": "^1.2.2",
    "gulp-run": "^1.6.7",
    "gulp-tslint": "^2.0.0",
    "gulp-typescript": "^2.6.0",
    "gulp-uglify": "^1.2.0",
    "karma": "^0.12.31",
    "karma-chai": "^0.1.0",
    "karma-coverage": "^0.3.0",
    "karma-mocha": "^0.1.10",
    "karma-phantomjs-launcher": "^0.1.4",
    "karma-sinon": "^1.0.4",
    "mocha": "^2.2.4",
    "run-sequence": "^1.0.2",
    "sinon": "^1.14.1",
    "typescript": "^1.5.0-alpha",
    "vinyl-buffer": "^1.0.0",
    "vinyl-source-stream": "^1.1.0"
  },
  "readme": "# InversifyJS\n[![Join the chat at https://gitter.im/inversify/InversifyJS](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/inversify/InversifyJS?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![Build Status](https://secure.travis-ci.org/inversify/InversifyJS.png?branch=master)](https://travis-ci.org/inversify/InversifyJS)\n[![Coverage Status](https://coveralls.io/repos/inversify/InversifyJS/badge.svg?branch=master)](https://coveralls.io/r/inversify/InversifyJS?branch=master)\n[![npm version](https://badge.fury.io/js/inversify.svg)](http://badge.fury.io/js/inversify)\n[![Dependencies](https://david-dm.org/inversify/InversifyJS.png)](https://david-dm.org/inversify/InversifyJS#info=dependencies)\n[![img](https://david-dm.org/inversify/InversifyJS/dev-status.png)](https://david-dm.org/inversify/InversifyJS/#info=devDependencies)\n[![img](https://david-dm.org/inversify/InversifyJS/peer-status.png)](https://david-dm.org/inversify/InversifyJS/#info=peerDependenciess)\n\nA lightweight IoC container written in TypeScript.\nVisit http://inversify.io/ for more information.\n\n### About\nInversifyJS is a lightweight (4KB) pico inversion of control (IoC) container for TypeScript and JavaScript apps. A pico IoC container uses a class constructor to identify and inject its dependencies.\n\nInversifyJS is easy to integrate with the majority of existing JavaScript frameworks and encourage the usage of the best OOP and IoC practices.\n\n### Motivation\nJavaScript applications are becoming larger and larger day after day. As a result we are using a lot of our architecture exprience from languages like Java or C# in JavaScript. We are embracing OOP with JavaScript but we are not writting SOLID JavaScript. InversifyJS has been designed to allow JavaScript developers to write code that adheres to the SOLID principles.\n\n### Philosophy\nInversifyJS has been developed with 3 main goals:\n\n1. Allow JavaScript developers to write code that adheres to the SOLID principles.\n\n2. Facilitate and encourage the adherance to the best OOP and IoC practices.\n\n3. Add as litle runtime overhead as possible.\n\n# Installation\n\nYou can get the latest release using NPM or Bower.\n```\nnpm install inversify --save\n```\n\n```\nbower install inversify --save\n```\n\n# The Basics (with TypeScript)\nThe main goal of InversifyJS is top allow JavaScript developers to write code that adheres to the SOLID principles. Many of these principles refer to the usage of interfaces. The main reason why it is not possible to write native SOLID JavaScript is becase the language lacks interfaces. In the other hand, TypeScript features interfaces, so, if you are going to use InversifyJS it is recommended to work with TypeScript to get the most out of it.\n\n#### 1. Declare interfaces & implementations\n\nOur goal is to write SOLID code. This means that we should \"depend upon Abstractions. Do not depend upon concretions.\" so we will start by declaring some interfaces (abstractions).\n\n```\ninterface FooInterface {\n  log() : void;\n}\n\ninterface BarInterface {\n  log() : void;\n}\n\ninterface FooBarInterface {\n  log() : void;\n}\n```\n\nWe can continue declaring some classes which implement them (concretions). We will start by declaring two classes (Foo & Bar) which don't have any dependencies.\n\n```\nclass Foo implements FooInterface {\n  public log(){\n    console.log(\"foo\");\n  }\n}\n\nclass Bar implements BarInterface {\n  public log(){\n    console.log(\"bar\");\n  }\n}\n```\n\nNow we are going to declare a class named FooBar, which has two dependencies (FooInterface & BarInterface). Note that the names of the arguments in its constructor are significant because the injector uses these to look up the dependencies.\n\n```\nclass FooBar implements FooBarInterface {\n  public foo : FooInterface;\n  public bar : BarInterface;\n  public log(){\n    console.log(\"foobar\");\n  }\n  constructor(FooInterface : FooInterface, BarInterface : BarInterface) {\n    this.foo = FooInterface;\n    this.bar = BarInterface;\n  }\n}\n```\n\n#### 2. Bind interfaces to implementations\n\nBefore we can start resolving and injecting dependencies we need to create an instance of the InversifyJS Kernel class. The Kernel will automatically detect is a class has some dependencies by examining its constructor. Note that the names of the arguments in the class constructor are significant because the injector uses these to look up the dependencies.\n\n```\n// kernel\nvar kernel = new inversify.Kernel();\n```\n\nIn order to resolve a depencency, the kernel needs to be told which implementation type (classes) to associate with each service type (interfaces). We will use type bindigns for this purpose. A type binding (or just a binding) is a mapping between a service type (an interface), and an implementation type (class).\n\n```\n// bind\nkernel.bind(new inversify.TypeBinding<FooInterface>(\"FooInterface\", Foo));\nkernel.bind(new inversify.TypeBinding<BarInterface>(\"BarInterface\", Bar));\nkernel.bind(new inversify.TypeBinding<FooBarInterface>(\"FooBarInterface\", FooBar));\n```\n\nWhen we declare a type binding, the TypeScript compiler will check that the implementation type (class) is actually and implementation of the service type (interface) and throw a compilation error if that is not the case.\n\n```\n// Compilation error: Bar does not implement FooInterface\nkernel.bind(new inversify.TypeBinding<FooInterface>(\"FooInterface\", Bar));\n```\n\nWe should keep the InversifyJS Kernel instantiation and type bindings centralized in one unique IoC configuration file. This will help us to abstract our application from the IoC configuration.\n\n#### 3. Resolve & inject dependencies\n\nAfter declaring the type bindigns, we can invoke the kernel resolve method to resolve a dependency. We will use a string as the interface identifier (instead of the interface itself) because the TypeScript interfaces are not available at runtime.\n\n```\nvar foobar = kernel.resolve<FooBarInterface>(\"FooBarInterface\");\n```\n\nIf the interface that we are tyring to resolve is bind to a class that has some dependencies, InversifyJS will resolve and inject them into a new instance via the class constructor.\n\n```\n// Foo and Bar instances has been injected into a new Foobar instance via its constructor\nfoobar.foo.log(); // foo\nfoobar.bar.log(); // bar\nfoobar.log();     // foobar\n```\n\nOur application dependency tree should have one unique root element, known as the application composition root, which is the only place where we should invoke the resolve method.\n\nInvoking resolve everytime we need to inject something, as if it was a Service Locator is an anti-pattern. If we are working with an MVC framweork the composition root should be located in the application class, somewhere along the routing logic or in a controller factory class. Please refer to the integration examples if you need additional help.\n\n# Integration with popular frameworks\n\nInversifyJS was designed with many popular JavaScript frameworks in mind. As a result, it is really easy to integrate with existing JavaScript frameworks and examples of integration withmany popular frameworks are available in the [official repository](https://github.com/inversify/Inversify-code-samples).\n\n# Good Practices\nDependency Inversion (DI) isn't rocket science. We just need to try to avoid new and singleton except when there's a compelling reason to use them, such as a utility method that has no external dependencies, or a utility class that could not possibly have any purpose outside the framework (interop wrappers and dictionary keys are common examples of this).\n\nMany of the problems with IoC frameworks come up when developers are first learning how to use them, and instead of actually changing the way they handle dependencies and abstractions to fit the IoC model, instead try to manipulate the IoC container to meet the expectations of their old coding style, which would often involve high coupling and low cohesion.\n\n#### Use a Composition Root to avoid the Service Locator anti-pattern\n\nOur application dependency tree should have one unique root element (known as the application composition root) which is the only component where we should invoke the resolve method.\n\nInvoking resolve everytime we need to inject something, as if it was a Service Locator is an anti-pattern. If we are working with an MVC framweork the composition root should be located in the application class, somewhere along the routing logic or in a controller factory class.\n\n#### Avoid Constructor over-injection\n\nConstructor over-injection is a violation of the Single Responsibility Principle. Too many constructor arguments indicates too many dependencies; too many dependencies indicates that the class is trying to do too much. Usually this error correlates with other code smells, such as unusually long or ambiguous (\"manager\") class names.\n\n#### Avoid the injection of data, as opposed to behaviour\n\nInjection of data, as opposed to behaviour, is a subtype of the poltergeist anti-pattern, with the 'geist in this case being the container. If a class needs to be aware of the current date and time, you don't inject a DateTime, which is data; instead, you inject an abstraction over the system clock. This is not only correct for DI; it is absolutely essential for testability, so that you can test time-varying functions without needing to actually wait on them.\n\n#### Avoid declaring every life cycle as Singleton\n\nDeclaring every life cycle as Singleton is, to me, a perfect example of cargo cult programming and to a lesser degree the colloquially-named \"object cesspool\". I've seen more singleton abuse than I care to remember, and very little of it involves DI.\n\n#### Avoid implementation-specific interface types\n\nAnother common error is implementation-specific interface types done just to be able to register it in the container. This is in and of itself a violation of the Dependency Inversion Principle (just because it's an interface, does not mean it's truly abstract) and often also includes interface bloat which violates the Interface Segregation Principle.\n\n#### Avoid optional dependencies\n\nIn other words, there is a constructor that accepts dependency injection, but also another constructor that uses a \"default\" implementation. This also violates the DIP and tends to lead to LSP violations as well, as developers, over time, start making assumptions around the default implementation, and/or start new-ing up instances using the default constructor.\n\n# License\n\nLicense under the MIT License (MIT)\n\nCopyright © 2015 [Remo H. Jansen](http://www.remojansen.com)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n",
  "readmeFilename": "README.md",
  "gitHead": "11357775618785bfe8e5c25511c8a909ae89d633",
  "_id": "inversify@1.0.0",
  "_shasum": "c14126995b841d89f0a76ca910443437a14a619b",
  "_from": "inversify@>=1.0.0 <2.0.0"
}
